name: SonarQube (stage)

on:
  push:
    branches: [ "stage" ]
  pull_request:
    branches: [ "stage" ]  # PRs cuyo base es stage (validaci칩n previa al merge)

jobs:
  sonarqube:
    # Ejecuta en push a stage, o en PR dev->stage
    if: >
      github.event_name == 'push' ||
      (github.event_name == 'pull_request' &&
       github.base_ref == 'stage' &&
       github.head_ref == 'dev')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # recomendado para un an치lisis correcto

      # --- Paso de an치lisis con el action oficial ---
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          # Para SonarQube Server (self-hosted); para Cloud no es necesario:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      # --- Falla el job si el Quality Gate est치 en rojo ---
      - name: SonarQube Quality Gate
        uses: SonarSource/sonarqube-quality-gate-action@v1.2.0
        with:
          pollingTimeoutSec: 600
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          # Opcional para Server:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

##### OWASP DEPENDENCY CHECK

      # Preparamos un lock reproducible desde pyproject.toml
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Generate requirements.txt from pyproject
        run: |
          python -m pip install --upgrade pip
          pip install pip-tools
          pip-compile pyproject.toml -o requirements.txt --resolver=backtracking

      # Cache de la base de datos NVD de Dependency-Check
      - name: Cache Dependency-Check data
        uses: actions/cache@v4
        with:
          path: ./.dc
          key: ${{ runner.os }}-dc-${{ hashFiles('pyproject.toml', 'requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-dc-

      - name: Run OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        env:
          NVD_API_KEY: ${{ secrets.NVD_API_KEY }}  # opcional
        with:
          project: ${{ github.repository }}
          path: '.'
          format: 'HTML,JSON'          # Generamos HTML + JSON para el control personalizado
          out: 'reports'
          args: >-
            --data ./.dc
            --nvdApiKey ${{ env.NVD_API_KEY }}
            --exclude "**/venv/**"
            --exclude "**/.venv/**"
            --exclude "**/site-packages/**"
            --scan .

      - name: Upload Dependency-Check HTML report
        uses: actions/upload-artifact@v4
        with:
          name: dependency-check-html
          path: reports/dependency-check-report.html

      - name: Fail if more than 1 vulnerability
        run: |
          python - << 'PY'
          import json, sys, pathlib
          report = pathlib.Path('reports/dependency-check-report.json')
          if not report.exists():
              print("Dependency-Check JSON report not found; failing to be safe.")
              sys.exit(1)
          with report.open() as f:
              data = json.load(f)
          total = 0
          for dep in data.get('dependencies', []):
              vulns = dep.get('vulnerabilities') or []
              total += len(vulns)
          print(f"Total vulnerabilities found: {total}")
          if total > 1:
              sys.exit(1)
          PY
